Package frank;

Helpers

/*Caracteres*/

	mais_ou_menos = '+'|'-';
	ul = '_';
	ast = '*';
	barra = '/';
	
	
/*Blank*/

	sp = ' ';
	tab = 9;
	cr = 13;
	nl = 10;
	blank = sp | cr | nl | tab;
	
/*Operadores*/
	menor = '<';
	igual = '=';
	neg = '!';
	ponto = '.';
	
/*Números*/

	digit = ['0' .. '9'];
	digits = mais_ou_menos? digit+;
	hexad = ['0'.. '9'] | ['a' .. 'f'] | ['A' .. 'F'];
	hex = '0x' hexad+;
	flut = digits ponto digits;

/*Letras*/

	char = ['a' .. 'z'] | ['A' .. 'Z'];
	all = [0 .. 0xFFFF]; 
	sem_quebra = [all - nl];
	sem_ast = [all - ast];

Tokens

/*Futuro Ignored Tokens*/
	blank = blank+;
	comment_block = barra ast ((sem_ast)* ast)+ barra;
	comment_line = barra barra (sem_quebra)* nl;
	tab = tab;
	espaco = sp+;

/*Palavras reservadas*/

	/*Variáveis*/
	int = 'int';
	real = 'real';
	bool = 'bool';
	var = 'var';
	size = 'size';
	cons = 'cons';
	
	/*RW*/
	print = 'print';
	read = 'read';
	
	/*Loops e condicionais*/
	while = 'while';
	if = 'if';
	else = 'else';
	then = 'then';
	
	/*Lógicos*/
	and = 'and';
	or = 'or';
	true = 'true';
	false = 'false';
	
	/*Etc*/
	function = 'function';
	procedure = 'procedure';
 
/*Símbolos*/
 
	/*Delimitadores*/
	sym_left_par = '(';
	sym_right_par = ')';
	sym_left_ket = '[';
	sym_right_ket = ']';
	sym_left_ces = '{';
	sym_right_ces = '}';
	sym_semicolon = ';';
	sym_colon = ',';
	sym_barra = '|';
	
	/*Matemática*/

	sym_plus = '+';
	sym_minus = '-';
	sym_mult = '*';
	sym_div = '/';
	sym_mod = '%';
 
	/*Comparação*/
	sym_equal = igual;
	sym_lesser = menor;
	sym_neg = neg;
 
 	/*Declaração*/
	sym_dec = ':=';
	
	/*Outros lexemas*/
	integer = (digits | hex);
	float = ((flut) | (flut ('E' | 'e') digits));
	identifier = (char | ul)(char | digits | ul)*;
 
Ignored Tokens

	comment_block,
	comment_line,
	espaco,
	tab,
	blank;
 
 Productions
 
 programa =
 	{vazio}
 	| {dec_var} dec+
 	| {dec_proc_func} dec_proc_func+
 	| {tudo} dec+ dec_proc_func+;
 
 
 
 /*            FUNÇÕES E PROCEDIMENTOS           */
 
 dec_proc_func =
 	{proc} dec_procedimento
 	| {func} dec_funcao;
 	
 dec_print =
 	print sym_left_par exp sym_right_par sym_semicolon;
 	
 dec_read = 
 	read sym_left_par parametro sym_right_par sym_semicolon;
 
 dec_procedimento = 
 	{simples} procedure identifier sym_left_par sym_right_par comando
 	| {composto} procedure identifier sym_left_par parametros sym_right_par bloco;
 
 dec_funcao = 
 	{simples} function tipo identifier sym_left_par sym_right_par exp;
 	//| {composto} function tipo identifier sym_left_par parametros sym_right_par exp;
 
 parametros = 
 	{simples} parametro
 	| {composto} parametros sym_colon parametro;
 
 
 parametro = 
 	{sem_var} tipo_param identifier
 	|{com_var} var tipo_param identifier;
 
 tipo_param =
 	{base} tipo_base
 	| {param} tipo_param sym_left_ket sym_right_ket;
 
 /*                    COMANDOS                  */
 
 comando_if = 
 	{sem_else} if sym_left_par exp sym_right_par comando
 	|{com_else} if sym_left_par exp sym_right_par bloco else comando;
 
 
 comando =
 	{bloco} bloco
 	| {if} comando_if
 	| {while} while sym_left_par exp sym_right_par comando
 	| {dec} variavel sym_dec exp sym_semicolon
 	| {chamada} chamada
 	| {print} dec_print
 	| {read} dec_read;
	
 bloco = 
 	{dec} sym_left_ces dec+ sym_right_ces
 	| {comando} sym_left_ces comando+ sym_right_ces
 	| {dec_comando} sym_left_ces dec+ comando+ sym_right_ces;
	
	
 /*                    EXPRESSÕES                */
 
 exp = 
 	{or} exp_or;

 exp_or = 
 	{and} exp_and
 	| {or} exp_or or exp_and;
 	
 exp_and = 
 	 {equal} exp_equal
 	| {and} exp_and and exp_equal;

 exp_equal = 
  	{lesser} exp_lesser
 	| {equal} exp_equal sym_equal exp_lesser;
 
 exp_lesser = 
 	{mat} exp_mat
 	| {lesser} exp_lesser sym_lesser exp_mat;

 exp_mat =
	{fator} exp_fator
	| {soma} exp_mat sym_plus exp_fator
	| {menos} exp_mat sym_minus exp_fator;

 exp_fator =
	{exp_bool} exp_bool
	| {mult} exp_fator sym_mult exp_bool
	| {div} exp_fator sym_div exp_bool
	| {mod} exp_fator sym_mod exp_bool;
	
 exp_bool =
 	{valor} exp_if
 	| {not} sym_neg exp_if;
 	
 exp_if =
 	{exp} exp_termo
 	| {if} if sym_left_par exp_if sym_right_par exp_then;
 	
 exp_then =
 	then exp exp_else;
 	
 exp_else = 
 	else exp_if;

 exp_termo =
	{valor} valor
	| {variavel} variavel
	| {par} sym_left_par exp sym_right_par
	| {chamada} chamada
 	| {bloco} bloco_exp;

 chamada = 
 	{simples} identifier sym_left_par sym_right_par
 	|{composta} identifier sym_left_par dec_exp sym_right_par;
 
 bloco_exp =
 	{simples} sym_left_ces exp sym_right_ces
 	|{composto} sym_left_ces dec_cons+ exp sym_right_ces;
 
 dec_exp = 
 	{simples} exp
 	|{composta} dec_exp sym_colon exp;
	

 /*                  DECLARAÇÕES                 */
 
 dec = 
 	{dec_var} dec_var
 	| {dec_cons} dec_cons;
 
 dec_var =
 	{ini} var tipo dec_ini sym_semicolon
 	|{id} var tipo dec_id sym_semicolon;
 	
 dec_id = 
 	{simples} identifier
 	|{composta} dec_id sym_colon identifier;
 
 dec_cons =
 	cons tipo dec_ini sym_semicolon;
 
 dec_ini = 
 	{simples} inicializacao
 	|{composta} dec_ini sym_colon inicializacao;
 
 inicializacao = 
 	{exp} identifier sym_dec exp
 	|{array_ext} identifier sym_dec array_ext
 	|{array_comp} identifier sym_dec array_comp;
 	
 
 array_ext = 
 	sym_left_ket dec_exp sym_right_ket;
 
 array_comp = 
 	{array} sym_left_ket identifier sym_barra array_comp sym_right_ket
 	| {exp} sym_left_ket identifier sym_barra exp sym_right_ket;
 
 tipo = 
 	{simples} tipo_base
 	|{vetor} tipo sym_left_ket exp sym_right_ket;
 
 tipo_base =
 	{int} int
 	| {bool} bool
 	| {real} real;
 
 valor =
 	{numero} numero
 	| {true} true
 	| {false} false;
 
 numero =
 	{int} integer
 	| {float} float;
 	
 variavel = 
 	{simples} identifier
 	| {vetor} variavel sym_left_ket exp sym_right_ket;
 	
 /*                    COMENTÁRIO INCRÍVEL                */
	
	